Greek text readable with "cat". Not with "pico".

sdi1900047

H εργασία έχει υλοποιηθεί σε c++.

Είναι χωρισμένη σε 5 αρχεία κώδικα (dataServer.cpp, serverCommunication.cpp, serverWorker.cpp, remoteClient.cpp, commonFuncs.cpp) και 4 κεφαλίδες
(commonFuncs.h, serverTypes.h, serverCommunication.h, serverWorker.h). Στο dataServer.cpp βρίσκεται ο κώδικας του main thread του server, στο
serverCommunication.cpp ο κώδικας των communication threads, στο serverWorker.cpp ο κώδικας των worker threads, στο remoteClient.cpp ο κώδικας του
client, και στο commonFuncs.cpp διάφορες βοητητικές συναρτήσεις.

Τα αρχεία .cpp είναι στον κατάλογο src, τα .h στον include, τα .o μπαίνουν στον build, τα εκτελέσιμα στον bin.

Με την εντολή make all φτιάχνονται όλα τα εκτελέσιμα (dataServer και remoteClient), με την make run_server φτιάχνεται και τρέχει ο server με κάποια
default ορίσματα, με την make run_client φτιάχνεται και τρέχει ο client με default ορίσματα που ταιριάζουν στου server, με την make clean καθαρίζουν
τα αντικειμενικά και τα εκτελέσιμα, και με την make cleanup καθαρίζεται ο κατάλογος output. Υπάρχει ένας κατάλογος Server με δοκιμαστικά αρχεία όπως
αυτά της εκφώνησης ο οποίος αντιγράφεται στην περίπτωση default ορισμάτων στον client.

Αν σταματήσετε και τρέξετε τον server γρήγορα ενώ δεν έχει προλάβει το σύστημα να ολοκληρώσει την διαδικασία κλεισίματος του socket, μπορεί να προκύψει
το error "Address already in use".

Ο client αντιγράφει τον κατάλογο που ζητάει μέσα σε έναν κατάλογο output που δημιουργείται εκεί από όπου τρέχει. Ο server ψάχνει για τον αιτούμενο
κατάλογο ξεκινώντας από εκεί όπου τρέχει. Π.χ., αν ο client που τρέχει στο client_dir αιτηθεί το ../req_dir, ο server που τρέχει στο parent/dir θα ψάξει
για το parent/req_dir και αν βρεθεί ο client θα το βάλει στο client_dir/output/req_dir.

Έχουν γίνει οι παραδοχές πως στο σύστημα αρχείων του client δεν υπάρχουν κατάλογοι στο ίδιο σημείο και με το ίδιο όνομα όπου θα πρέπει να μεταφερθεί
αρχείο (στο παράδειγμα εδώ, να μην υπάρχει κατάλογος του τύπου output/Server/file2/), πως ενόσω τρέχει ο server δεν θα γίνονται αλλαγές στον κατάλογο
που μεταφέρεται, και πως ο server θα τρέχει 24/7 και δεν θα κλείνει ποτέ υπό φυσιολογικές συνθήκες.

Έχει γίνει η σχεδιαστική επιλογή πως στην περίπτωση λάθους στον server για το οποίο φταίει μάλλον κάτι από την πλευρά του server (π.χ. δεν μπορούν
να δημιουργηθούν threads), ο server τερματίζει, ενώ στην περίπτωση λάθους για το οποίο ευθύνεται μάλλον ο client (π.χ. δεν υπάρχει ο κατάλογος που
αιτήθηκε), σταματάει απλά το αντίστοιχο communication thread και ο server συνεχίζει κανονικά. Γενικά έχει γίνει η προσπάθια ένας client να μην μπορεί,
επίτηδες ή όχι, να ρίξει τον server, υπό φυσιολογικές συνθήκες. Στις περιπτώσεις λάθους από close/closedir, απλά εμφανίζεται μήνυμα λάθους και δεν
γίνεται τίποτα άλλο, εφόσον δεν εμποδίζουν το πρόγραμμα από το να συνεχίσει. Αν ο client ζητήσει κάποιο κατάλογο που περιέχει αρχείο στο οποίο δεν έχει
πρόσβαση ο server, αυτό απλά αγνοείται και μεταφέρονται τα υπόλοιπα.

Γενικά ο κώδικας ακολουθεί κυρίως procedure-oriented λογική, χρησιμοποιώντας το string και το queue από την stl αλλά χωρίς την δημιουργία νέων κλάσεων.

Το πρωτόκολλο επικοινωνίας είναι το εξής:

Ο client στέλνει το σχετικό μονοπάτι του καταλόγου που θέλει σαν null-terminated string.
Ο server στέλνει μια ακολουθία μηνυμάτων με την εξής δομή: πρώτα το όνομα του μονοπατιού του αρχείου σαν null-terminated string, μετά το μέγεθος του
αρχείου σε bytes σαν uint32_t (που θα καταλαμβάνει πάντα sizeof(uint32_t) bytes) και μετά τα περιεχόμενα του αρχείου. Όταν τελειώσει, στέλνει το κενό
string σαν όνομα αρχείου (ένα μηδενικό byte), ώστε να καταλάβει ο client ότι έχει λάβει όλα τα αρχεία, και πως ο server δεν έκλεισε την σύνδεση για
κάποιον άλλον λόγο.

Ο client δουλεύει ως εξής:

Αρχικά αρχικοποιεί τις παραμέτρους από το command line. Μετά φτιάχνει σύνδεση με τον server και στέλνει τον κατάλογο που θέλει. Για κάθε ένα μήνυμα
που δέχεται, που αφορά ένα αρχείο, φτιάχνει τους αντίστοιχους καταλόγους, αν δεν υπάρχουν, και σβήνει πρώτα το αρχείο αν υπάρχει ήδη. Αν κλείσει η
σύνδεση πριν τελειώσει η διαδικασία, τυπώνει μήνυμα λάθους. Για οποιοδήποτε error τυπώνεται μήνυμα λάθους, και αν δεν είναι από το close το πρόγραμμα
τερματίζει με κωδικό διάφορο του 0.

Ο server δουλεύει ως εξής:

Αρχικά φτιάχνει μια global ουρά από tasks, ένα πλήθος από detached worker threads και ένα socket στο οποίο περιμένει συνδέσεις. Κάθε φορά που συνδέεται
κάτι, φτιάχνει ένα communication thread για να το διαχειριστεί.
Το communication thread φτιάχνει μια δομή με πληροφορίες για το socket, συμπεριλαμβανομένου και του αριθμού των tasks που απομένουν (αρχικά 0), διαβάζει
το αίτημα, και ψάχνει αναδρομικά τον κατάλογο, φτιάχνοντας για κάθε αρχείο ένα task που περιέχει πληροφορίες για το αρχείο και το socket, αυξάνοντας το
πλήθος των εναπομείνοντων tasks, και βάζοντάς το στην ουρά (περιμένοντας μέχρι να υπάρχει χώρος). Μετά περιμένει μέχρι να τελειώσουν όλα τα δικά του
tasks, και όταν γίνει αυτό στέλνει το αντίστοιχο μήνυμα στον client, κλείνει το socket και το thread τερματίζει.
Το κάθε worker thread περιμένει μέχρι να βρεί στην ουρά κάποιο task, οπότε στέλνει το αντίστοιχο αρχείο στον αντίστοιχο client, μειώνει το πλήθος των
εναπομείνοντων tasks πάνω σε αυτό το socket κατά 1, και ενημερώνει το αντίστοιχο communication thread.
Η πρόσβαση σε κοινά δεδομένα προστατεύεται με mutexes και τα threads περιμένουν όπου χρειάζεται με condition variables. Αν υπάρξει λάθος για το οποίο
φταίει ο client σε κάποιο worker thread, το task σταματάει και θεωρείται πως ολοκληρώθηκε, ενώ αν φταίει ο server, τότε τερματίζει.
